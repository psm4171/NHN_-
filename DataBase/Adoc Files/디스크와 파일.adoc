# 디스크와 파일

데이터베이스의 내부 데이터는 디스크나 테이프와 같은 저장 장치에 저장된다. 

디스크 관리자는 가용한 디스크 공간을 추가하는 역할을 수행한다. 

![스크린샷 2023-11-09 오전 9.35.21.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/30914778-8bfa-404a-8db1-10f28062c17e/e7baa70c-90d3-45fc-a097-bbc09880043b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-09_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.35.21.png)

데이터베이스 시스템의 데이터는 일반적으로 상당한 대용량이기 때문에 테이프나 디스크 같은상대적으로 속도가 느린 저장장치가 중요한 역할을 수행합니다. 

모든 데이터를 저장할 수 있는 주 기억장치를 갖추는 것은 매우 어려운 일이므로 데이터를 디스크나 테이프에 저장하는 것이 일반적이며, 데이터베이스 시스템은 필요할 때마다 낮은 계층의 저장장치로부터 데이터를 가져오도록 구성됩니다.

![스크린샷 2023-11-09 오전 10.17.07.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/30914778-8bfa-404a-8db1-10f28062c17e/0e910e8c-8d2c-4160-9077-3c9e6cd4ce80/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-09_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.17.07.png)

비휘발성 메모리와 하드 디스크 드라이브에서 데이터를 저장하고

광학 디스크와 자기 테이프에서 데이터를 백업한다. 

폰 노이만 구조 시스템에서 실행되는 전형적인 명령-실행 사이클

1. 메모리로부터 명령을 인출 
2. 명령을 명령 레지스터에 저장
3. 명령 해독은 메모리로부터 피연산자를 인출하여 내부 레지스터에 저장하도록 유발
4. 피연산자에 대한 명령을 실행한 후에 결과가 메모리에 다시 저장. 

이상적으로는 데이터가 모드 메인 메모리에 존재하는 것입니다. 하지만 메인 메모리는 필요한 데이터를 영구히 저장하기에는 너무 작고, 또한 전원이 공급되지 않으면 데이터가 모두 지워지는 **소멸성(Volatile) 저장장치**입니다. 데이터는 영구적으로 저장되어야 하고, 따라서 **비소멸성(nonvolatile) 저장장치**인 디스크나 테이프를 사용합니다.

테이프는 비용이 저렴하며 대용량의 데이터를 사용할 수 있는 저장 매체

테이프의 가장 큰 결점 : 순차 접근 장치.

테이프를 사용할 때에는 반드시 모든 데이터를 순차적으로 검색해야 하며, 원하는 위치로 직접 접근하는 것은 불가능합니다. 예를 들어 테이프의 마지막 바이트를 접근하려면 테이프 전체를 읽어 들어야 합니다. 따라서 운영용 데이터나 자주 사용되는 데이터를 저장하는데 테이프를 사용하는 것은 불가능합니다. 테이프는 데이터를 주기적으로 백업 받을 때 사용됩니다.

**[HDD (Hard Disk Drive)](https://github.com/gikpreet/class-relational_database/blob/main/Module%2003%20%EB%94%94%EC%8A%A4%ED%81%AC%EC%99%80%20%ED%8C%8C%EC%9D%BC/06_hdd.adoc#hdd-hard-disk-drive)**

- 기계 장치가 포함된 저장장치로, 자기를 이용하여 데이터를 저장하고 읽음
- 순차 접근 방식이 아닌 직접 접근 방식
- 디스크가 회전도 많이 하고, 탐색도 많이 해야하므로 속도가 느림.  블럭들을 붙여주면 속도가 향상
- 디스크는 테이프에 비해 원하는 위치로 직접 이동이 가능하다. → dbms 응용에 널리 사용되는 장치
- 전통적인 방식의 자기 디스크인 HDD

HDD는 전통적인 방식의 자기 디스크입니다. 자기를 이용해서 플래터에 데이터를 쓰거나 읽습니다. 플래터의 중심에는 플래터를 고정하는 스핀들이 있고, 스핀들이 회전하여 회전하는 플래터에 쓰여진 데이터를 디스크 헤드가 읽거나 데이터를 쓰는 방식으로 동작합니다.

데이터는 디스크 내에서 **디스크 블록(Disk Block)**이라고 하는 단위로 저장됩니다. 디스크 블록은 바이트의 연속으로서 디스크에서 입출력이 이루어지는 단위입니다. 블록은 하나 이상의 **플래터(Platter)**에서 **트랙(Track)**이라는 동심원을 따라 배치됩니다. 최근의 디스크는 트랙이 플래터의 양쪽 모두에 저장됩니다. 모든 플래터에서 직경이 같은 트랙들이 모이면 원통 모양이 되고, 이를 **실린더(Cylinder)**라고 합니다. 실린더난 한 플래터 면 당 하나 씩의 트랙으로 구성됩니다. 각각의 트랙은 **섹터(Sector)**라고 하는 호로 나뉩니다. 섹터는 디스크 자체에 지정된 고유의 크기로 변경할 수 없습니다. 디스크 블록의 크기는 디스크를 초기화 할 때 지정합니다.

SSD(Solid State Drive)

- 플래시 메모리를 기반으로 한 저장 매체로, Random Access 가능한 빠른 속도의 저장 장치
- 모든 구성요소가 전기장치이며, 기계 장치를 가지지 않음
- HDD보다 빠른 SSD
- SSD는 플래시 메모리를 장점을 활용하여 HDD와 동일한 형태로 개발된 대용량 플래시 메모리
- 임의 접근 방식을 사용하여 탐색 시간없이 고속으로 데이터를 입출력할 수 있으며, 외부의 충격으로부터 데이터가 손상될 가능성이 적다.
- 

![스크린샷 2023-11-09 오전 9.58.12.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/30914778-8bfa-404a-8db1-10f28062c17e/73bc96e5-cd25-4439-8e68-566ad27bddb7/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-09_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.58.12.png)

SSD는 PD와 연결되는 **호스트 인터페이스 로직(Host Interface Logic)**과 데이터가 저장되는 **플래시 메모리(Flash Memory)**, 인터페이스와 플래시 메모리를 연결하고 제어하는 **SSD 컨트롤러(SSD Controller)**, 외부 장치와 SSD간 사이에서 버퍼 역할을 담당하는 **메모리 버퍼(Memory Buffer)**로 구성됩니다.

**버퍼 관리자(Buffer Manager)**는 필요할 때 마다 디스크로부터 페이지를 가져와서 기억장치에 적재할 책임이 있는 DBMS의 소프트웨어 계층입니다.

DBMS는 필요할 때 마다 데이터를 주 기억장치에 적재해야 하며, 언제 페이지를 교체해야 하는지를 결정해야 합니다.

버퍼 풀 

가용한 주 기억장치 공간을 페이지라는 단위로 분할한 데이터 적재 공간

즉, 주기억장치에서 페이지가 모여있는 공간을 **버퍼 풀(Buffer Pool)**이라고 합니다.

버퍼 풀내의 페이지를 **프레임(Frame)**이라고 하는데, 프레임은 페이지를 담을 수 있는 슬롯입니다.

사용자가 쿼리를 실행하면 

데이터베이스 

고정 길이 레코드 → 속도가 빠름, 산술적인 데이터를 삽입할 경우 

가변 길이 레코드 → 속도가 느림, 많은 데이터가 필요할 경우 효율적인 측면에서 유리, 

작성자가 게시판에 글을 작성할 때, 

글 번호 : INT 

글 제목: VARCHAR (가변 길이)

글 날짜: DATE (고정 길이)

작성자 ID: VARCHAR (가변 길이) 

글 내용: VARCHAR (글자 수 제한의 경우, 고정 길이)

 

이미지는 버킷을 참조하는 구조 

주민번호의 경우 → 고정 길이 레코드 

primitive는 고정 길이

String은 가변 길이

char의 시퀀스를 고정, 가변에 따라 성능의 차이가 발생한다. 

페이지 형식 

페이지는 레코드가 탑재되는 슬롯의 모임으로 생각할 수 있습니다. 

페이지 안에는 <페이지 번호, 슬롯 번호>의 쌍으로 식별됩니다.

고정 길이 레코드는 

순서대로 배치할 경우 읽을 때 유리하다. 

가변 길이 레코드 

레코드가 가변 길이면 페이지를 고정된 길이의 슬롯으로 분할 할 수 없습니다. 

슬롯 마다 <레코드 오프셋, 레코드 길이>의 형태로 슬롯 디렉토리를 유지합니다. 

어떠한 방식으로 사용되는 것이 효율적인지 판단해야 한다. 

게시판의 글을 검색하는 경우, 

게시판에 글 목록을 보는 경우 Scan / rangeScan / equality

특정 글을 읽는다 → 글 번호를 판별 

데이터베이스에서 가장 많이 일어나는 작업 : equality의 발생

작성자를 검색하는 경우 Scan을 사용 

글 번호는 정렬 되어 있기 때문에 equality로 검색 

→ 속도를 높이기 위해 RID는 메모리가 올라가면서 생기는 구조로 

파일과 인덱스 

시스템 카탈로그

데이터의 모든 데이터의 설명 정보를 저장한 것입니다. 

시스템 카탈로그는 관계형 데이터 형식으로 저장됩니다. 

메타 데이터, 데이터 사전이라고도 불립니다. 

테이블의 모든 컬럼, 데이터 타입… 

클러스터드 인덱스 

![스크린샷 2023-11-09 오후 3.46.32.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/30914778-8bfa-404a-8db1-10f28062c17e/53ab4b07-8573-4140-810a-01c95ac8136e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-09_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.46.32.png)

테이블의 레코드를 물리적으로 정렬하는 데 사용되는 인덱스 유형입니다. 

클러스터드 인덱스는 테이블의 물리적 구조를 변경하며, 테이블의 레코드를 클러스터드 인덱스 키의 순서대로 저장합니다. —> 검색과 범위 쿼리의 성능을 향상시키는 데 사용

![스크린샷 2023-11-09 오후 3.44.31.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/30914778-8bfa-404a-8db1-10f28062c17e/18819dde-81d1-42d1-a67c-b9d25c128698/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-09_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.44.31.png)

ProductNo가 자동 정렬되어 출력된 결과입니다. 

order by는 전체 처리로 데이터를 정렬하기 때문에 속도가 느리지만

index를 사용하면 쿼리 옵티마이저가  쿼리에 필요한 데이터를 빠르게 찾도록 합니다. 

즉, 미리 정렬된 데이터에 대한 레코드 위치만 찾으면 되므로 정렬 작업의 부담이 줄어듭니다.

→ 예를 들어, "ORDER BY"를 사용하지 않고 인덱스를 활용하여 특정 열의 값을 검색할 경우, 데이터베이스는 인덱스를 사용하여 원하는 순서로 데이터를 반환하므로 정렬 작업 없이 결과를 얻을 수 있습니다. 

이러한 이유로 인덱스를 사용하면 "ORDER BY"를 사용하는 것보다 데이터 정렬 속도가 빨라집니다.
